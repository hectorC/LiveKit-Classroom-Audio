<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LiveKit Classroom – Student</title>
  <link rel="stylesheet" href="/styles.css" />
</head>

<body class="page page--student">
  <main class="shell">
    <header class="hero">
      <span class="hero__tag">Student Portal</span>
      <h1>Immerse in the Audio Feed</h1>
      <p>Breathe in a shimmering stream of live sound. One click tunes you into the teacher console with almost no
        delay.</p>
    </header>

    <section class="panel">
      <div class="status-block">
        <span class="status-label">Status</span>
        <span class="status-pill" id="statusPill" data-state="disconnected">
          <span id="status">Not connected</span>
        </span>
      </div>

      <div class="control-grid">
        <div>
          <label>&nbsp;</label>
          <button id="listenBtn" type="button">Listen</button>
        </div>
      </div>

      <div class="timeline">
        <div class="timeline__step">
          <span class="timeline__dot"></span>
          <span class="timeline__text">Tap Listen to request a secure pass for this room.</span>
        </div>
        <div class="timeline__step">
          <span class="timeline__dot"></span>
          <span class="timeline__text">Stay on the page while the connection stabilizes and syncs.</span>
        </div>
        <div class="timeline__step">
          <span class="timeline__dot"></span>
          <span class="timeline__text">Enjoy the mix—your headphones auto-play as soon as sound arrives.</span>
        </div>
      </div>
      <p class="footer-note">Listener lane • Auto reconnect • Local network only</p>
    </section>
  </main>

  <!-- LiveKit JS SDK (served locally for offline LAN use) -->
  <script src="/livekit-client.umd.min.js"></script>

  <script>
    const statusEl = document.getElementById('status');
    const button = document.getElementById('listenBtn');
    const statusPill = document.getElementById('statusPill');

    const wsUrl = "ws://" + window.location.hostname + ":7880";

    let room = null;
    let isListening = false;
    let attachedAudioTrack = null;
    let wakeLock = null;

    // Reusable audio element (more reliable on mobile than anonymous detached elements)
    const audioEl = document.createElement('audio');
    audioEl.autoplay = true;
    audioEl.playsInline = true;
    audioEl.controls = false;
    audioEl.preload = 'auto';
    audioEl.style.display = 'none';
    document.body.appendChild(audioEl);

    async function requestWakeLock() {
      // Best-effort: keeps screen from auto-locking, which helps avoid background audio throttling on Android.
      if (!('wakeLock' in navigator)) return;
      try {
        if (wakeLock) return;
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
          console.log('Wake lock released');
          wakeLock = null;
        });
        console.log('Wake lock acquired');
      } catch (e) {
        console.warn('Wake lock request failed:', e);
        wakeLock = null;
      }
    }

    function releaseWakeLock() {
      try {
        if (wakeLock) {
          wakeLock.release();
        }
      } catch (e) {
        console.warn('Wake lock release failed:', e);
      } finally {
        wakeLock = null;
      }
    }

    function updateStatus(message, state = 'disconnected') {
      statusEl.textContent = message;
      statusPill.dataset.state = state;
    }

    async function fetchStudentToken() {
      const res = await fetch("/token/student");
      const data = await res.json();

      console.log("Student identity:", data.identity);
      console.log("Raw student token value from server:", data.token);

      let token = data.token;

      if (typeof token === "object" && token !== null) {
        if (typeof token.jwt === "string") {
          token = token.jwt;
        } else if (typeof token.token === "string") {
          token = token.token;
        } else {
          console.warn("Unexpected student token object shape:", token);
          token = JSON.stringify(token);
        }
      }

      token = String(token);
      console.log("Student token typeof (fixed):", typeof token);
      console.log("Student token sample:", token.slice(0, 40));

      return token;
    }


    async function start() {
      try {
        updateStatus("Connecting...", 'disconnected');

        // Keep the device from auto-locking while listening (when supported).
        requestWakeLock();

        // Prime audio playback on the user gesture (helps with mobile autoplay policies)
        // Important: don't await here, some browsers may leave the promise pending
        // when there is no media source yet, which would block connecting.
        audioEl.muted = true;
        try {
          const primePromise = audioEl.play();
          if (primePromise && typeof primePromise.catch === 'function') {
            primePromise.catch(() => { /* ignore; we'll retry after attach */ });
          }
        } catch (_) {
          // Ignore; we'll retry once a real track is attached.
        }
        // Unmute shortly after priming so real audio can play once attached.
        setTimeout(() => { audioEl.muted = false; }, 0);

        const token = await fetchStudentToken();

        room = new LivekitClient.Room();

        room.on(LivekitClient.RoomEvent.ParticipantConnected, (p) => {
          console.log("Participant connected:", p.identity);
        });

        room.on(LivekitClient.RoomEvent.TrackPublished, (pub, participant) => {
          console.log("Track published by", participant.identity, pub);
        });

        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
          console.log("Track subscribed:", track, "from", participant.identity);

          if (track.kind === LivekitClient.Track.Kind.Audio) {
            // Attach to a single persistent audio element (more reliable on mobile / lock-unlock)
            try {
              if (attachedAudioTrack && attachedAudioTrack !== track) {
                attachedAudioTrack.detach(audioEl);
              }
            } catch (e) {
              console.warn('Failed detaching previous audio track:', e);
            }

            track.attach(audioEl);
            attachedAudioTrack = track;

            // Best-effort: ensure playback is active
            const playPromise = audioEl.play();
            if (playPromise && typeof playPromise.catch === 'function') {
              playPromise.catch((e) => console.warn('audioEl.play() was blocked or failed:', e));
            }
            updateStatus("Listening to " + participant.identity, 'connected');
            isListening = true;
          }
        });

        room.on(LivekitClient.RoomEvent.Disconnected, () => {
          updateStatus("Disconnected", 'disconnected');
          button.disabled = false;
          isListening = false;
          releaseWakeLock();
          try {
            if (attachedAudioTrack) {
              attachedAudioTrack.detach(audioEl);
            }
          } catch (e) {
            console.warn('Failed detaching audio on disconnect:', e);
          } finally {
            attachedAudioTrack = null;
          }
        });

        await room.connect(wsUrl, token);
        if (!isListening) {
          updateStatus("Connected. Waiting for teacher audio...", 'disconnected');
        }
        button.disabled = true;

      } catch (e) {
        console.error(e);
        updateStatus("Error: " + e, 'error');
      }
    }

    button.addEventListener('click', start);

    // When returning from lock/background, try to resume audio playback.
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && isListening) {
        requestWakeLock();
        const playPromise = audioEl.play();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch((e) => console.warn('audioEl.play() retry failed:', e));
        }
      }
    });

    // Release wake lock when navigating away.
    window.addEventListener('pagehide', () => releaseWakeLock());
  </script>
</body>

</html>